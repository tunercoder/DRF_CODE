python inbuilt package json

python object to json ----> json.dump(python object) 

json to python object -----> json.load(json data)


Serializers:  do serialization Convert Complex data such as queryset or model instance to python native data type and then same can be changed to json/xml for frontend

deserialization is process of converting incoming parsed data to api after validating it convert to complex datatype


For defining a serializer we need to create a serializer class in serializer.py file which is very similar to form or model form class in django

DRF provides a modelserializer class for creating serializer in shortcut.


form django_restframework import serializers

class StudentSerializer(serializers.Serializer):
	name = serializers.Charfield()
	rollno = serializers.Integerfield()
	city = serializers.charfield()


Process of serialization:
complex datatype(this process is serialization)  ---------> python native type (render converted data as json)---------> render in json

How to achieve:

For single object:

create model instance
	stu= Student.objects.get(id=1)

converting instance (complex data type) stu to native python datatype/serialized object:
	serializer = StudentSerializer(stu)
	
For queryset:

create queryset 
	stu= Student.objects.all()
	
converting queryset (complex data type) stu to native python datatype/serialized object:
	serializer = StudentSerializer(stu,many=True)
	
	
To check what data is there in serializer use data attribute

	serializer.data
	

JSONRenderer: convert to json

This is used to render serialized data into Json we use render method of JSONRenderer which is understanble by frontend
	from django_restframework.renderers import JSONRenderer
	json_data=JSONRenderer().render(serializer.data)
	
	
JsonResponse class: HttpResponse class subclass used to create Json encoded reponse its default content type is json.Used as shortcut
instead of calling jsonrender and then wrapping it in httpreponse object we can directly pass serializer.data into JsonResponse
Note: Parameter safe =False for multiple objects explicitly as same is not dict object as for single instance case

Serializer Fields and Core Arguments in Django REST Framework:


De-serialization:

Serializers are responsible for deserialization means it allows parsed data to be converted back to complex datatype, after validating the incoming data


Json data (this is called parsed_data)----------> python native datatype --------->(deserialization) complex datatype

Process

Gett stream by BytesIO

import io
stream = io.BytesIO(json)

Now  parse json data to python native datatype by jsonparser

from rest_framework.parsers import JSONParser
parsed_data = JSONParser().parse(stream)

Deserialization: Convert parse_data to complex datatype after validating incoming data by is_valid method

Create serializer object with parse_data :

serializer = StudentSerializer(data=parsed_data)  #THis line convert native datatypes into a dictionary of validated data.

validate data:

serializer.is_valid() # True means data is valid


See what data is there if valid:

serializer.validated_data


See what errror is there if invalid:
serializer.error

Saving object to db (model object data to db):

Define a method create to create a new object in db with POST request in serializer class:

def create(self, validated_data):
        return Student.objects.create(**validated_data)


UPDATE DATA:

Complete Update:

by default serializer must be passed all values for all required fields otherwise they will raise validation errors.
To update complete data means PUT request with all fields to be updated create a methon named update in serializer class
instance is old data of object stored in db curretly and validated_data is data to be updated.

def update(self, instance, validated_data):
        instance.name = validated_data.get('email', instance.name)
        instance.roll = validated_data.get('content', instance.roll)
        instance.city = validated_data.get('created', instance.city)
        instance.save()
        return instance
		
in view:
	serializer = StudentSerializer(stu,data=pythondata)
	if serializer.is_valid():
		serializer.save()
		
Patial Data update means patch request:
 for partial data update pass an extra argumwent partial=True in StudentSerializer.Rest all is same.
 
in view:
	serializer = StudentSerializer(stu,data=pythondata,partial=True)
	if serializer.is_valid():
		serializer.save()
 
 

		
Validation on fields:

there are 3 type of validations which can be done:

Field level validation: we can specify field level validation by adding a validate_fieldname method in our serializer class similar to clean_fieldname method in Django forms
validate_fieldname should return a validated value or raise a serializers.ValidationError

Syntax:

class StudentSerializer(serializers.Serializer)
.
.
.
	def validate_roll(self,value):
		if value >= 200:
			raise serializers.ValitationError("seats full")
		return value

Note: validate_roll is invoked when is_valid method is called.		

	
Object level validation: When we need to do validation that requires multiple fields we do object level validation by adding a  method called validate() in our serializers class
it should return a validated value or raise a serializers.ValidationError

Syntax: 

class StudentSerializer(serializers.Serializer)
.

.
	def validate(self,data):
		name = data.get('name')
		city = data.get('city')
		if name.lower() =="rohit" and city.lower() != "ddn":
			raise serializers.ValitationError("City must be  DDN")
		return data

Note: data is dictionary of all fields values passed to serializer

Validators: Soetime you want to place your validation logic into reusable commponents so that it can be easily be reused thorughout your code base
.THis can be achieved by using validator functions and validator classes.

Syntax:

define a method for validator in serializer class

def stat_with_r(value):
	if value[0].lower() != 'r':
		raise serializers.ValidationError("name should start with r")
	return value
	
class StudentSerializer(serializers.Serializer)
	name=serializers.CharField(max_length=100,validators=[stat_with_r]) 
	
Note: we can pass list of validators in fields validators attribute

Priority: validators----field level=====object level

	
ModelSerializer Class:ModelSerializer Class provides shortcut that lets you automatically create a serializer class with fields that corresponds to the model fields.

Difference between  ModelSerializer and regular serializer class:

Fields are automatically generated for serializer based on field in model.
It provides deafault implementation for create and update method for serialization
it automatically generates validators for serializer such as unique_together validators.

How to create ModelSerializer:

class StudentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Student
        fields = ['name','roll','city']



Validation in ModelSerializer:Simple as we do for serializers we define it in class here

class StudentSerializer(serializers.ModelSerializer):
    #validators reusable
    def start_with_r(value):
        if value[0].lower() != 'r':
            raise serializers.ValidationError("name should start with r")
        return value
        
    #validation for specific single field name can be added like this in ModelSerializer
    # name=serializers.CharField(read_only=True)
    name=serializers.CharField(validators=[start_with_r])
    class Meta:
        model = Student
        fields = ['name','roll','city']
        # read_only_fields=['name','roll'] #to allow multiple field validations on ModelSerializer in single line
        # extra_kwargs={'name':{'read_only':True}} #validation properties using extra_kwargs attribute in ModelSerializers


#Field level validations:
    def validate_roll(self,value):
        if value >= 200:
            raise serializers.ValidationError('seats full!!')
        return value


#Object level validation:
    def validate(self,data):
        nm = data.get('name')
        ct = data.get('city')
        if nm.lower() == "rohit" and ct.lower() != 'ddn':
            raise serializers.ValidationError('City must be DDN for rohit!!')
        return data
        


FUnction based API View decorator : api_view is a wrapper provides a bit of functionlities such as making sure your view recieves 
request instance and adding context to response objects so that content negotiation can be performed

This view will use the default renderers, parsers, authentication classes etc specified in the settings.
By default only GET methods will be accepted. Other methods will respond with "405 Method Not Allowed". 
this also checks for malfuncitoned data in request.data  and raises a parse error


syntax:

from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status

@api_view(['GET','POST'])
def student_list(request):
	if request.method == 'GET':
		stu=Student.objects.all()
		serializer=StudentSerializer(stu,many=True)
		return Response(serializer.data)
	
	if request.method == 'POST':
		serializer=StudentSerializer(data=request.data)
		if serializer.is_valid():
			serializer.save()
			res={'msg':'successfully created'}
			return Response(res,status=status.HTTP_201_CREATED)
		return Response(Serializer.error,status=status.HTTP_400_BAD_REQUEST)
		
		
Requests In rest_framework: In django we can relate itwith HttpRequest.

REST framework's Request class extends the standard HttpRequest, adding support for REST framework's flexible request parsing and request authentication.
	
REST framework's Request objects provide flexible request parsing that allows you to treat requests with JSON data or other media types in the same way that you would normally deal with form data.


.data property:

	request.data returns the parsed content of the request body(as we use request.body to get the json data of request). This is similar to the standard request.POST and request.FILES attributes except that:

	It includes all parsed content, including file and non-file inputs.
	It supports parsing the content of HTTP methods other than POST, meaning that you can access the content of PUT and PATCH requests.
	It supports REST framework's flexible request parsing, rather than just supporting form data. For example you can handle incoming JSON data similarly to how you handle incoming form data.


.query_params:

	request.query_params is a more correctly named synonym for request.GET in django .]


Response class:

	REST framework supports HTTP content negotiation by providing a Response class which allows you to return content that can be rendered into multiple content types, depending on the client request.

	Response objects are initialised with data, which should consist of native Python primitives. REST framework then uses standard HTTP content negotiation to determine how it should render the final response content.

	There's no requirement for you to use the Response class, you can also return regular HttpResponse or StreamingHttpResponse objects from your views if required. Using the Response class simply provides a nicer interface for returning content-negotiated Web API responses, that can be rendered to multiple formats.
	
	Unless you want to heavily customize REST framework for some reason, you should always use an APIView class or @api_view function for views that return Response objects. Doing so ensures that the view can perform content negotiation and select the appropriate renderer for the response, before it is returned from the view.

Signature: Response(data, status=None, template_name=None, headers=None, content_type=None)

	Unlike regular HttpResponse objects, you do not instantiate Response objects with rendered content. Instead you pass in unrendered data, which may consist of any Python primitives.

	The renderers used by the Response class cannot natively handle complex datatypes such as Django model instances, so you need to serialize the data into primitive datatypes before creating the Response object.

	You can use REST framework's Serializer classes to perform this data serialization, or use your own custom serialization.

	Arguments:

	data: The serialized data for the response.
	status: A status code for the response. Defaults to 200. See also status codes.
	template_name: A template name to use if HTMLRenderer is selected.
	headers: A dictionary of HTTP headers to use in the response.
	content_type: The content type of the response. Typically, this will be set automatically by the renderer as determined by content negotiation, but there may be some cases where you need to specify the content type explicitly.




Class-based API Views:REST framework provides an APIView class, which subclasses Django's View class.


	APIView classes are different from regular View classes in the following ways:

	Requests passed to the handler methods will be REST framework's Request instances, not Django's HttpRequest instances.
	Handler methods may return REST framework's Response, instead of Django's HttpResponse. The view will manage content negotiation and setting the correct renderer on the response.
	Any APIException exceptions will be caught and mediated into appropriate responses.
	Incoming requests will be authenticated and appropriate permission and/or throttle checks will be run before dispatching the request to the handler method.


HOw to write:

from rest_framework.views import APIView
from rest_framework.response import Response

class StudentAPI(APIView):
	def get(self,request,format=None):
		stu=Student.objects.all()
		serializer=StudentSerializer(stu,many=True)
		return Response(serializer.data)
	
	def post(self,request,format=None):
		serializer=StudentSerializer(data=request.data)
		if serializer.is_valid()
			serializer.save()
			return Response({'msg':'Data created'},status=status.HTTP_201_CREATED)
		return Response(serializer.errors,status=status.HTTP_400_BAD_REQUEST)
		
		
	
GenericAPIView class:

This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.

Attributes:
	Basic settings:

	The following attributes control the basic view behavior.

	queryset - The queryset that should be used for returning objects from this view. Typically, you must either set this attribute, or override the get_queryset() method. If you are overriding a view method, it is important that you call get_queryset() instead of accessing this property directly, as queryset will get evaluated once, and those results will be cached for all subsequent requests.
	serializer_class - The serializer class that should be used for validating and deserializing input, and for serializing output. Typically, you must either set this attribute, or override the get_serializer_class() method.
	lookup_field - The model field that should be used to for performing object lookup of individual model instances. Defaults to 'pk'. Note that when using hyperlinked APIs you'll need to ensure that both the API views and the serializer classes set the lookup fields if you need to use a custom value.
	lookup_url_kwarg - The URL keyword argument that should be used for object lookup. The URL conf should include a keyword argument corresponding to this value. If unset this defaults to using the same value as lookup_field.
	Pagination:

	The following attributes are used to control pagination when used with list views.

	pagination_class - The pagination class that should be used when paginating list results. Defaults to the same value as the DEFAULT_PAGINATION_CLASS setting, which is 'rest_framework.pagination.PageNumberPagination'. Setting pagination_class=None will disable pagination on this view.
	Filtering:

	filter_backends - A list of filter backend classes that should be used for filtering the queryset. Defaults to the same value as the DEFAULT_FILTER_BACKENDS setting.
	
	
Methods
Base methods:

get_queryset(self)

Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.

This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.

May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.


get_object(self)	
	
Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.


filter_queryset(self, queryset)
Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.


get_serializer_class(self)
Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.



Other methods:

You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.

get_serializer_context(self) - Returns a dictionary containing any extra context that should be supplied to the serializer. Defaults to including 'request', 'view' and 'format' keys.
get_serializer(self, instance=None, data=None, many=False, partial=False) - Returns a serializer instance.
get_paginated_response(self, data) - Returns a paginated style Response object.
paginate_queryset(self, queryset) - Paginate a queryset if required, either returning a page object, or None if pagination is not configured for this view.
filter_queryset(self, queryset) - Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.



Mixins:

The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.
The mixin classes can be imported from rest_framework.mixins.


ListModelMixin
	Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.
	If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.

example:
	from rest_framework.mixins import ListModelMixin
	from rest_framework.generics import GenericAPIView
	class StudentList(GenericAPIView,ListModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def get(self,request,*args,**kwargs):
			return self.list(request,*args,**kwargs)
		
		
CreateModelMixin
	Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.
	If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.
	If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.


example:
	from rest_framework.mixins import CreateModelMixin
	from rest_framework.generics import GenericAPIView
	class StudentCreate(GenericAPIView,CreateModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def post(self,request,*args,**kwargs):
			return self.create(request,*args,**kwargs)
	
	
RetrieveModelMixin #for single object
	Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.
	If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.


example:
	from rest_framework.mixins import RetrieveModelMixin
	from rest_framework.generics import GenericAPIView
	class StudentRetrieve(GenericAPIView,RetrieveModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def get(self,request,*args,**kwargs):
			return self.retrieve(request,*args,**kwargs)
			
			
UpdateModelMixin
	Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.
	Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.
	If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.
	If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.


example:

	from rest_framework.mixins import UpdateModelMixin
	from rest_framework.generics import GenericAPIView
	class StudentUpdate(GenericAPIView,UpdateModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def put(self,request,*args,**kwargs):
			return self.update(request,*args,**kwargs)

		def patch(self,request,*args,**kwargs):
			return self.partial_update(request,*args,**kwargs)

			
DestroyModelMixin
	Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.
	If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.
	
example:

	from rest_framework.mixins import DestroyModelMixin
	from rest_framework.generics import GenericAPIView
	class StudentDelete(GenericAPIView,DestroyModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def delete(self,request,*args,**kwargs):
			return self.destroy(request,*args,**kwargs)
		

We can group list and create and update delete and retrieve in single classes as:



class StudentListAndCreate(GenericAPIView,ListModelMixin,CreateModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def get(self,request,*args,**kwargs):
			return self.list(request,*args,**kwargs)
		
		def post(self,request,*args,**kwargs):
			return self.create(request,*args,**kwargs)



class StudentRetrieveUpdatedelete(GenericAPIView,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		def get(self,request,*args,**kwargs):
			return self.retrieve(request,*args,**kwargs)

		def put(self,request,*args,**kwargs):
			return self.update(request,*args,**kwargs)

		def patch(self,request,*args,**kwargs):
			return self.partial_update(request,*args,**kwargs)
		
		def delete(self,request,*args,**kwargs):
			return self.destroy(request,*args,**kwargs)
	
	
	
Concrete View Classes:
	The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.
	The view classes can be imported from rest_framework.generics.
	
	
CreateAPIView
	Used for create-only endpoints.
	Provides a post method handler.
	Extends: GenericAPIView, CreateModelMixin

ListAPIView
	Used for read-only endpoints to represent a collection of model instances.
	Provides a get method handler.
	Extends: GenericAPIView, ListModelMixin

RetrieveAPIView
	Used for read-only endpoints to represent a single model instance.
	Provides a get method handler.
	Extends: GenericAPIView, RetrieveModelMixin

DestroyAPIView
	Used for delete-only endpoints for a single model instance.
	Provides a delete method handler.
	Extends: GenericAPIView, DestroyModelMixin

UpdateAPIView
	Used for update-only endpoints for a single model instance.
	Provides put and patch method handlers.
	Extends: GenericAPIView, UpdateModelMixin

ListCreateAPIView
	Used for read-write endpoints to represent a collection of model instances.
	Provides get and post method handlers.
	Extends: GenericAPIView, ListModelMixin, CreateModelMixin

RetrieveUpdateAPIView
	Used for read or update endpoints to represent a single model instance.
	Provides get, put and patch method handlers.
	Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin

RetrieveDestroyAPIView
	Used for read or delete endpoints to represent a single model instance.
	Provides get and delete method handlers.
	Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin

RetrieveUpdateDestroyAPIView
	Used for read-write-delete endpoints to represent a single model instance.
	Provides get, put, patch and delete method handlers.
	Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin


Example:

To list all:

	from rest_framework.generics import ListAPIView
	class StudentList(ListAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
To create :
	
	from rest_framework.generics import CreateAPIView
	class StudentList(CreateAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
	
To get single object:

	from rest_framework.generics import RetrieveAPIView
	class StudentList(RetrieveAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
To update:

	from rest_framework.generics import UpdateAPIView
	class StudentList(UpdateAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
TO delete:

	from rest_framework.generics import DestroyAPIView
	class StudentList(DestroyAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
	
TO list and create:
	
	from rest_framework.generics import ListCreateAPIView
	class StudentList(ListCreateAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
TO retrieve and update:
	
	from rest_framework.generics import RetrieveUpdateAPIView
	class StudentList(RetrieveUpdateAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		
TO retrieve and delete:
	
	from rest_framework.generics import RetrieveDestroyAPIView
	class StudentList(RetrieveDestroyAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer
		
		
TO retrieve update and delete:
	
	from rest_framework.generics import RetrieveUpdateDestroyAPIView
	class StudentList(RetrieveUpdateDestroyAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer


We can do crude by 2 classes only:

	class StudentListCreate(ListCreateAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer

		
	# TO retrieve update and delete:

	class StudentRetrieveUpdateDestroy(RetrieveUpdateDestroyAPIView):
		queryset=Student.objects.all()
		serializer_class=StudentSerializer



ViewSets:

	Django REST framework allows you to combine the logic for a set of related views in a single class, called a ViewSet
	There are two main advantages of using a ViewSet class over using a View class.

		1. Repeated logic can be combined into a single class. In the above example, we only need to specify the queryset once, and it'll be used across multiple views.
		2. By using routers, we no longer need to deal with wiring up the URL conf ourselves.
	
	Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.


ViewSet class:

	A ViewSet class is simply a type of class-based View, that does not provide any method handlers such as .get() or .post(), and instead provides actions such as .list() and .create() .retrieve() .update() .partial_update() .destroy().


Example:

from rest_framework import viewsets

class StudentViewSet(viewsets.ViewSet):

    def list(self, request):
        pass

    def create(self, request):
        pass

    def retrieve(self, request, pk=None):
        pass

    def update(self, request, pk=None):
        pass

    def partial_update(self, request, pk=None):
        pass

    def destroy(self, request, pk=None):
        pass


ViewSet actions/attribute:

During dispatch, the following attributes are available on the ViewSet.

	basename - the base to use for the URL names that are created.
	action - the name of the current action (e.g., list, create).
	detail - boolean indicating if the current action is configured for a list or detail view.
	suffix - the display suffix for the viewset type - mirrors the detail attribute.
	name - the display name for the viewset. This argument is mutually exclusive to suffix.
	description - the display description for the individual view of a viewset.		
	
	
Example of action attribute:
	
	You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the list action similar to this:

	def get_permissions(self):
		"""
		Instantiates and returns the list of permissions that this view requires.
		"""
		if self.action == 'list':
			permission_classes = [IsAuthenticated]
		else:
			permission_classes = [IsAdmin]
		return [permission() for permission in permission_classes]
	
	
How to define a router for viewset in urls.py file: Typically, rather than explicitly registering the views in a viewset in 		the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.
	

	from django.urls import path,include
	from api.views import StudenViewSet
	from rest_framework.routers import DefaultRouter

	router = DefaultRouter()# this line creates a default router object

	router.register('studentapi', StudenViewSet, basename='student')# this line registers our viewset with router

	urlpatterns = [
			path('',include(router.urls)), #This line API urls are determined automatically buy the router



ModelViewSet Class:

ViewSet:
	The ViewSet class inherits from APIView. You can use any of the standard attributes such as permission_classes, authentication_classes in order to control the API policy on the viewset.
	The ViewSet class does not provide any implementations of actions. In order to use a ViewSet class you'll override the class and define the action implementations explicitly.

GenericViewSet:
	The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default.
	In order to use a GenericViewSet class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.

ModelViewSet Class:	
	The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.
	The actions provided by the ModelViewSet class are .list(), .retrieve(), .create(), .update(), .partial_update(), and .destroy().So in case of
	ViewSet we will use ModelViewSet.
	
	
Example:
	class StudenViewSet(viewsets.ModelViewSet):
		"""
		A simple ViewSet for viewing and editing students.
		"""
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
		
		
		
ReadOnlyModelViewSet:
	The ReadOnlyModelViewSet class also inherits from GenericAPIView. As with ModelViewSet it also includes implementations for various actions, but unlike ModelViewSet only provides the 'read-only' actions, .list() and .retrieve().

	Example
	As with ModelViewSet, you'll normally need to provide at least the queryset and serializer_class attributes. For example:

	class StudenViewSet(viewsets.ReadOnlyModelViewSet):
		"""
		A simple ViewSet for viewing accounts.
		"""
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
			

Authentication:
	
	Authentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The permission and throttling policies can then use those credentials to determine if the request should be permitted.
	Authentication is always run at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.
	
	Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.
	
2 Main properties that are used in authentication are:
	
	The request.user property will typically be set to an instance of the contrib.auth package's User class.

	The request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.
	

Type of Authentication DRF supports:
	
	REST framework provides a number of authentication schemes out of the box, and also allows you to implement custom schemes.

	BasicAuthentication
	SessionAuthentication
	TokenAuthentication
	RemoteUserAuthentication
	CustomAuthentication
	

How authentication is determined:
	The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.

	If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None.

	The value of request.user and request.auth for unauthenticated requests can be modified using the UNAUTHENTICATED_USER and UNAUTHENTICATED_TOKEN settings.

Setting the authentication scheme:

1> Globally authencation in setting.py.will be applied on all views.

	the default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.

	REST_FRAMEWORK = {
		'DEFAULT_AUTHENTICATION_CLASSES': [
			'rest_framework.authentication.BasicAuthentication',
			'rest_framework.authentication.SessionAuthentication',
		]
	}
	
2>You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.

	from rest_framework.authentication import SessionAuthentication, BasicAuthentication
	from rest_framework.permissions import IsAuthenticated
	from rest_framework.response import Response
	from rest_framework.views import APIView

	class ExampleView(APIView):
		authentication_classes = [SessionAuthentication, BasicAuthentication]
		permission_classes = [IsAuthenticated]
		.
		. 	
		.
		
3> if you're using the @api_view decorator with function based views.

	@api_view(['GET'])
	@authentication_classes([SessionAuthentication, BasicAuthentication])
	@permission_classes([IsAuthenticated])
	def example_view(request, format=None):
		Pass
	
BasicAuthentication:

	This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password. Basic authentication is generally only appropriate for testing.

	If successfully authenticated, BasicAuthentication provides the following credentials.

		request.user will be a Django User instance.
		request.auth will be None.
	
	Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:

	WWW-Authenticate: Basic realm="api"
	
	Note: If you use BasicAuthentication in production you must ensure that your API is only available over https. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.

Example:

	class StudentModelViewSet(viewsets.ModelViewSet):
		authentication_classes = [BasicAuthentication]
		permission_classes = [IsAuthenticated]
	
	
SessionAuthentication:
	This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.

	If successfully authenticated, SessionAuthentication provides the following credentials.

	request.user will be a Django User instance.
	request.auth will be None.
	Unauthenticated responses that are denied permission will result in an HTTP 403 Forbidden response.

	If you're using an AJAX style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any "unsafe" HTTP method calls, such as PUT, PATCH, POST or DELETE requests. See the Django CSRF documentation for more details.

Example:
	class StudentModelViewSet(viewsets.ModelViewSet):
		authentication_classes = [SessionAuthentication]
		permission_classes = [IsAuthenticated]
		
		
		
		
Before moving to coding and other authencation scheme we will learn permissions as they are needed in code too.

Permissions:
	Permissions are used to grant or deny access for different classes of users to different parts of the API.
	Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.	
	
How permissions are determined:

	Permissions in REST framework are always defined as a list of permission classes.

	Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.

	When the permissions checks fail either a "403 Forbidden" or a "401 Unauthorized" response will be returned, according to the following rules:

	The request was successfully authenticated, but permission was denied. — An HTTP 403 Forbidden response will be returned.
	
	The request was not successfully authenticated, and the highest priority authentication class does not use WWW-Authenticate headers. — An HTTP 403 Forbidden response will be returned.
	
	The request was not successfully authenticated, and the highest priority authentication class does use WWW-Authenticate headers. — An HTTP 401 Unauthorized response, with an appropriate WWW-Authenticate header will be returned.	

Permission classes provided by DRF are:

	AllowAny
	IsAuthenticated
	IsAdminUser
	IsAuthenticatedOrReadOnly	
	DjangoModelPermissions
	DjangoModelPermissionsOrAnonReadOnly
	DjangoObjectPermissions
	Custom permissions	


AllowAny
	The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.

	This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.

IsAuthenticated
	The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.

	This permission is suitable if you want your API to only be accessible to registered users.

IsAdminUser
	The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.

	This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.
	
	
IsAuthenticatedOrReadOnly
	The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the "safe" methods; GET, HEAD or OPTIONS.

	This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.		


DjangoModelPermissions
	This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.

	POST requests require the user to have the add permission on the model.
	PUT and PATCH requests require the user to have the change permission on the model.
	DELETE requests require the user to have the delete permission on the model.
	The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.

	To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.

DjangoModelPermissionsOrAnonReadOnly
	Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.


DjangoObjectPermissions
	This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.

	As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.

	POST requests require the user to have the add permission on the model instance.
	PUT and PATCH requests require the user to have the change permission on the model instance.
	DELETE requests require the user to have the delete permission on the model instance.
	
Custom permissions:

	To implement a custom permission, override BasePermission and implement either, or both, of the following methods:

	.has_permission(self, request, view)
	.has_object_permission(self, request, view, obj)
	
	The methods should return True if the request should be granted access, and False otherwise.
	
	
	Create a separate file custompermissions.py file and write custom permission class and overridde above methods as per your logic
	
	
TokenAuthentication:
	This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.

	To use the TokenAuthentication scheme you'll need to configure the authentication classes to include TokenAuthentication, and additionally include rest_framework.authtoken in your INSTALLED_APPS setting:

	INSTALLED_APPS = [
		...
		'rest_framework.authtoken'
	]	
	
	Note: Make sure to run manage.py migrate after changing your settings. The rest_framework.authtoken app provides Django database migrations.


What response if succcess or fail:

	If successfully authenticated, TokenAuthentication provides the following credentials.

	request.user will be a Django User instance.
	request.auth will be a rest_framework.authtoken.models.Token instance.
	
	Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header.
	For example:
	WWW-Authenticate: Token
	
	
How to generate a token:
 
 Using Admin panel

	It is also possible to create Tokens manually through admin interface. 

 Using management command 
 
	Using Django manage.py command
	Since version 3.6.4 it's possible to generate a user token using the following command:

	python manage.py drf_create_token <username>
	
	this command will return the API token for the given user, creating it if it doesn't exist:

	Generated token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b for user user1
	
	In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:
	python manage.py drf_create_token -r <username>
	
By exposing an api endpoint: this is the way by which client can create or ask existing token for themselves

	When using TokenAuthentication, you may want to provide a mechanism for clients to obtain a token given the username and password.
	REST framework provides a built-in view to provide this behavior. To use it, add the obtain_auth_token view to your URLconf:
	Add this path in urlconf:

	from rest_framework.authtoken import views
	urlpatterns += [
		path('get-token/', views.obtain_auth_token)
	]

	Note : that the URL part of the pattern can be whatever you want to use.

	
	The obtain_auth_token view will return a JSON response when valid username and password fields are POSTed to the view using form data or JSON:

	example :
	
	Request: http POST http://127.0.0.1:8000/get-token/ username="userq" password="1234232"
	
	Response :

		{ 'token' : '9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b' }

customized version of obtain_auth_token view:

	If you need a customized version of the obtain_auth_token view, you can do so by subclassing the ObtainAuthToken view class, and using that in your url conf instead.

	For example, you may return additional user information beyond the token value:

	from rest_framework.authtoken.views import ObtainAuthToken
	from rest_framework.authtoken.models import Token
	from rest_framework.response import Response

	class CustomAuthToken(ObtainAuthToken):

		def post(self, request, *args, **kwargs):
			serializer = self.serializer_class(data=request.data,
											context={'request': request})
			serializer.is_valid(raise_exception=True)
			user = serializer.validated_data['user']
			token, created = Token.objects.get_or_create(user=user)
			return Response({
				'token': token.key,
				'user_id': user.pk,
				'email': user.email
			})

And in your urls.py:

	urlpatterns += [
		path('api-token-auth/', CustomAuthToken.as_view())
	]


By using signals:
	If you want every user to have an automatically generated Token, you can simply catch the User's post_save signal.

	from django.conf import settings
	from django.db.models.signals import post_save
	from django.dispatch import receiver
	from rest_framework.authtoken.models import Token

	@receiver(post_save, sender=settings.AUTH_USER_MODEL)
	def create_auth_token(sender, instance=None, created=False, **kwargs):
		if created:
			Token.objects.create(user=instance)
	
	Note that you'll want to ensure you place this code snippet in an installed models.py module, or some other location that will be imported by Django on startup.	



How to test:
	For testing token based authencation The command line tool like HTTPie or curl may be useful for testing token authenticated APIs. For example:

	by curl making a token based get request:

		curl -X GET http://127.0.0.1:8000/api/example/ -H 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b'
		
	by HTTPie :

		http http://127.0.0.1:8000/studentapi/ 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b'
		
	Note: If you use TokenAuthentication in production you must ensure that your API is only available over https.






Custom authentication:
	To implement a custom authentication scheme, subclass BaseAuthentication and override the .authenticate(self, request) method. The method should return a two-tuple of (user, auth) if authentication succeeds, or None otherwise.

	In some circumstances instead of returning None, you may want to raise an AuthenticationFailed exception from the .authenticate() method.

	Typically the approach you should take is:

	If authentication is not attempted, return None. Any other authentication schemes also in use will still be checked.
	If authentication is attempted but fails, raise a AuthenticationFailed exception. An error response will be returned immediately, regardless of any permissions checks, and without checking any other authentication schemes.


	from django.contrib.auth.models import User
	from rest_framework import authentication
	from rest_framework import exceptions

	class ExampleAuthentication(authentication.BaseAuthentication):
		def authenticate(self, request):
			username = request.META.get('HTTP_X_USERNAME')
			if not username:
				return None
			try:
				user = User.objects.get(username=username)
			except User.DoesNotExist:
				raise exceptions.AuthenticationFailed('No such user')

			return (user, None)


Third party packages for authentication:

	The following third party packages are also available.

	Django OAuth Toolkit
	Django REST framework OAuth
	JSON Web Token Authentication
	Hawk HTTP Authentication
	HTTP Signature Authentication
	Djoser
	django-rest-auth / dj-rest-auth
	django-rest-framework-social-oauth2
	django-rest-knox
	drfpasswordless

we will learn JSON Web Token Authentication JWT only:

JWT:
	JSON Web Token is a fairly new standard which can be used for token-based authentication. 
	Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a
	database to validate a token. A package for JWT authentication is djangorestframework-simplejwt 
	which provides some features as well as a pluggable token blacklist app

djangorestframework-simplejwt package for JWT auth in DRF:

	A JSON Web Token authentication plugin for the Django REST Framework.
	Simple JWT provides a JSON Web Token authentication backend for the Django REST Framework. It aims to cover the most common use cases of JWTs by offering a conservative set of default features. It also aims to be easily extensible in case a desired feature is not present.


How to install:
	pip install djangorestframework-simplejwt


Configure simple JWT:

For global auth total application:

	In settings.py, add rest_framework_simplejwt.authentication.
	JWTAuthentication to the list of authentication classes:

	REST_FRAMEWORK = {
		'DEFAULT_AUTHENTICATION_CLASSES': (
			'rest_framework_simplejwt.authentication.JWTAuthentication',
		)
	}

	Also, in your root urls.py file (or any other url config), include routes for Simple JWT’s TokenObtainPairView and TokenRefreshView views:

	from rest_framework_simplejwt.views import TokenObtainPairView,TokenRefreshView,TokenVerifyView

	urlpatterns = [
		path('gettoken/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
		path('refreshtoken/', TokenRefreshView.as_view(), name='token_refresh'),
		path('verifytoken/', TokenVerifyView.as_view(), name='token_verify'),
	]

	last line  of verifytoken is optional You can also include a route for Simple JWT’s TokenVerifyView 
	if you wish to allow API users to verify tokens.


JWT default setting :

	Some of Simple JWT’s behavior can be customized through settings variables in settings.py:


	# Django project settings.py

	from datetime import timedelta

	...

	SIMPLE_JWT = {
		'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),
		'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
		'ROTATE_REFRESH_TOKENS': False,
		'BLACKLIST_AFTER_ROTATION': True,
		'UPDATE_LAST_LOGIN': False,

		'ALGORITHM': 'HS256',
		'SIGNING_KEY': settings.SECRET_KEY,
		'VERIFYING_KEY': None,
		'AUDIENCE': None,
		'ISSUER': None,

		'AUTH_HEADER_TYPES': ('Bearer',),
		'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
		'USER_ID_FIELD': 'id',
		'USER_ID_CLAIM': 'user_id',
		'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',

		'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
		'TOKEN_TYPE_CLAIM': 'token_type',

		'JTI_CLAIM': 'jti',

		'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
		'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
		'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
	}

	Read details at https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html




	USe JWT : 
	How to get a access and refresh token first time:
		we have to make a POST request with username and password to gettoken api end point

		http POST http://127.0.0.1:8000/gettoken/ username="user1" password="suman2008"

		in response :

		{
		"access":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU",
		"refresh":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4"
		}

	How to verfiy Access token is valid or expired:

		http POST http://localhost:8000/verifytoken/ token="<access token>"


	How to get a refreshed new access token again with help of refresh token without supplying username and password

		http POST http://localhost:8000/refreshtoken/ refresh="<refresh token>"

		Response: A new access response is Generated

		{"access":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNTY3LCJqdGkiOiJjNzE4ZTVkNjgzZWQ0NTQyYTU0NWJkM2VmMGI0ZGQ0ZSJ9.ekxRxgb9OKmHkfy-zs1Ro_xs1eMLXiR17dIDBVxeT-w"}

Permission classes will be implemented as other authentication on drf like a list.




Throttling:
	Throttling is similar to permissions, in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.
	As with permissions, multiple throttles may be used. Your API might have a restrictive throttle for unauthenticated requests, and a less restrictive throttle for authenticated requests.

How throttling is determined:
	As with permissions and authentication, throttling in REST framework is always defined as a list of classes.
	Before running the main body of the view each throttle in the list is checked. If any throttle check fails an exceptions.Throttled exception will be raised, and the main body of the view will not run.

Setting the throttling policy:

Globally:

	The default throttling policy may be set globally, using the DEFAULT_THROTTLE_CLASSES and DEFAULT_THROTTLE_RATES settings. For example.

	REST_FRAMEWORK = {
		'DEFAULT_THROTTLE_CLASSES': [
			'rest_framework.throttling.AnonRateThrottle',
			'rest_framework.throttling.UserRateThrottle'
		],
		'DEFAULT_THROTTLE_RATES': {
			'anon': '100/day',
			'user': '1000/day'
		}
	}

View Basis Throttling:
For CBV's:
	You can also set the throttling policy on a per-view or per-viewset basis, using the APIView class-based views.

	from rest_framework.throttling import UserRateThrottle
	from rest_framework.views import APIView

	class ExampleView(APIView):
		throttle_classes = [UserRateThrottle]
		.
		.
		.

For FBV's:

If you're using the @api_view decorator with function based views you can use the throttle_classes decorator.

	@api_view(['GET'])
	@throttle_classes([UserRateThrottle])
	def example_view(request, format=None):
		content = {
			'status': 'request was permitted'
		}
		return Response(content)


Types of throttle in DRF:

1>	AnonRateThrottle: The AnonRateThrottle will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.

	The allowed request rate is determined from one of the following (in order of preference).
		1. The rate property on the class, which may be provided by overriding AnonRateThrottle and setting the property.
		2. The DEFAULT_THROTTLE_RATES['anon']  in settings file.
	AnonRateThrottle is suitable if you want to restrict the rate of requests from unknown sources.

2> 	UserRateThrottle: The UserRateThrottle will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.

	The allowed request rate is determined from one of the following (in order of preference)
		1. The rate property on the class, which may be provided by overriding UserRateThrottle and setting the property.
		2. The DEFAULT_THROTTLE_RATES['user'] in settings file.

		An API may have multiple UserRateThrottles in place at the same time. To do so, override UserRateThrottle and set a unique "scope" for each class.

		For example, multiple user throttle rates could be implemented by using the following classes...

		class BurstRateThrottle(UserRateThrottle):
			scope = 'burst'

		class SustainedRateThrottle(UserRateThrottle):
			scope = 'sustained'
		...and the following settings.

		REST_FRAMEWORK = {
			'DEFAULT_THROTTLE_CLASSES': [
				'example.throttles.BurstRateThrottle',
				'example.throttles.SustainedRateThrottle'
			],
			'DEFAULT_THROTTLE_RATES': {
				'burst': '60/min',
				'sustained': '1000/day'
			}
		}

3> 	ScopedRateThrottle: The ScopedRateThrottle class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a .throttle_scope property. The unique throttle key will then be formed by concatenating the "scope" of the request with the unique user id or IP address.
The allowed request rate is determined by the
DEFAULT_THROTTLE_RATES setting using a key from the request "scope".

For example, given the following views...

	class ContactListView(APIView):
		throttle_scope = 'contacts'
		...


	class UploadView(APIView):
		throttle_scope = 'uploads'
		...

In settings rate are fixed by

	REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.ScopedRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'contacts': '1000/day',
        'uploads': '20/day'
    }
}

By this:
User requests to either ContactListView  would be restricted to a total of 1000 requests per-day.
User requests to UploadView would be restricted to 20 requests per day.



Filtering:	The default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.
The simplest way to filter the queryset of any view that subclasses GenericAPIView is to override the .get_queryset() method.
Overriding this method allows you to customize the queryset returned by the view in a number of different ways.


Types of filtering :

Generic Filtering:As well as being able to override the default queryset, REST framework also includes support for generic filtering backends that allow you to easily construct complex searches and filters.


DjangoFilterBackend
	The django-filter library includes a DjangoFilterBackend class which supports highly customizable field filtering for REST framework.

To use DjangoFilterBackend, first install django-filter.

	pip install django-filter

Then add 'django_filters' to Django's INSTALLED_APPS:

	INSTALLED_APPS = [
		...
		'django_filters',
		...
	]
You should now either add the filter backend to your settings:

	REST_FRAMEWORK = {
		'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
	}

Per View Setting:

Or add the filter backend to an individual View or ViewSet.

	from django_filters.rest_framework import DjangoFilterBackend

	class UserListView(generics.ListAPIView):
		...
		filter_backends = [DjangoFilterBackend]

If all you need is simple equality-based filtering, you can set a filterset_fields attribute on the view, or viewset, listing the set of fields you wish to filter against.

	class StudentList(generics.ListAPIView):
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
		filter_backends = [DjangoFilterBackend]
		filterset_fields = ['name', 'roll'] #Mention fields for which filter based is done

Url will be http://127.0.0.1:8000/studentapi/?name=ram&roll=1



Search Filter:The SearchFilter class supports simple single query parameter based searching, and is based on the Django admin's search functionality.

The SearchFilter class will only be applied if the view has a search_fields attribute set. The search_fields attribute should be a list of names of text type fields on the model, such as CharField or TextField.

Example:

	from rest_framework import filters

	class StudentList(generics.ListAPIView):
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
		filter_backends = [filters.SearchFilter]
		search_fields = ['name', 'city']




You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:

	search_fields = ['username', 'email', 'profile__profession']

By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched.
The search behavior may be restricted by prepending various characters to the search_fields.

'^' Starts-with search.
'=' Exact matches.
'@' Full-text search. (Currently only supported Django's PostgreSQL backend.)
'$' Regex search.


For example:

	search_fields = ['=name', '=city']


By default, the search parameter is named 'search', but this may be overridden with the SEARCH_PARAM setting.


To dynamically change search fields based on request content, it's possible to subclass the SearchFilter and override the get_search_fields() function. For example, the following subclass will only search on title if the query parameter title_only is in the request:

	from rest_framework import filters

	class CustomSearchFilter(filters.SearchFilter):
		def get_search_fields(self, view, request):
			if request.query_params.get('title_only'):
				return ['title']
			return super(CustomSearchFilter, self).get_search_fields(view, request)




OrderingFilter:The OrderingFilter class supports simple query parameter controlled ordering of results.
Its like orderby

By default, the query parameter is named 'ordering', but this may by overridden with the ORDERING_PARAM setting.

For example, to order users by username:

	http://example.com/api/users?ordering=username

pecify reverse orderings by prefixing the field name with '-', like so:

	http://example.com/api/users?ordering=-username

Multiple orderings may also be specified by comma separation:

	http://example.com/api/users?ordering=account,username


Specifying which fields may be ordered against
	It's recommended that you explicitly specify which fields the API should allowing in the ordering filter. You can do this by setting an ordering_fields attribute on the view, like so:

Example:

	class StudentList(generics.ListAPIView):
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
		filter_backends = [filters.OrderingFilter]
		ordering_fields = ['name', 'roll']
		ordering = ['username'] # Specifying a default ordering




Pagination:

REST framework includes support for customizable pagination styles. 
This allows you to modify how large result sets are split into individual pages of data.

There are 3 types of pagination :

	PageNumberPagination
	LimitOffsetPagination
	CursorPagination

How to enable Pagination:

Globally:

	The pagination style may be set globally as below:Mention pagination class and paze_size in settings.py file.

		REST_FRAMEWORK = {
			'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
			'PAGE_SIZE': 100
		}

Per View: You can also set the pagination class on an individual view by using the pagination_class attribute

	class StudentList(ListAPIView):
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
		pagination_class = PageNumberPagination


PageNumberPagination:This pagination style accepts a single number page number in the request query parameters.

How to Setup:To enable the PageNumberPagination style globally, use the following configuration, and set the PAGE_SIZE as desired:

	REST_FRAMEWORK = {
		'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
		'PAGE_SIZE': 100
	}

Request:Request will be containing a query param named page and a value.

GET https://api.example.org/accounts/?page=4

Configuration of attribute:
	The PageNumberPagination class includes a number of attributes that may be overridden to modify the pagination style.
	To set these attributes you should override the PageNumberPagination class, and then enable your custom pagination class as above.

	django_paginator_class - The Django Paginator class to use. Default is django.core.paginator.Paginator, which should be fine for most use cases.
	page_size - A numeric value indicating the page size. If set, this overrides the PAGE_SIZE setting. Defaults to the same value as the PAGE_SIZE settings key.
	page_query_param - A string value indicating the name of the query parameter to use for the pagination control.
	page_size_query_param - If set, this is a string value indicating the name of a query parameter that allows the client to set the page size on a per-request basis. Defaults to None, indicating that the client may not control the requested page size.
	max_page_size - If set, this is a numeric value indicating the maximum allowable requested page size. This attribute is only valid if page_size_query_param is also set.
	last_page_strings - A list or tuple of string values indicating values that may be used with the page_query_param to request the final page in the set. Defaults to ('last',)
	template - The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to None to disable HTML pagination controls completely. Defaults to "rest_framework/pagination/numbers.html".

For example we will subclass PageNumberPagination class to our custom paginator class :

	class MyPageNumberPagination(PageNumberPagination):
		page_size = 5
		page_size_query_param = 'records'
		max_page_size = 7

	in view we will use our custom class as pagination_class:

	class StudentList(ListAPIView):
		queryset = Student.objects.all()
		serializer_class = StudentSerializer
		pagination_class = MyPageNumberPagination	



LimitOffsetPagination: This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a "limit" and an "offset" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the page_size in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.

Request:

	GET https://api.example.org/accounts/?limit=100&offset=400 #100 per page and start by 400 th record

Setup
	To enable the LimitOffsetPagination style globally, use the following configuration:

	REST_FRAMEWORK = {
		'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination'
	}

Configuration: 
	The LimitOffsetPagination class includes a number of attributes that may be overridden to modify the pagination style.
	To set these attributes you should override the LimitOffsetPagination class, and then enable your custom pagination class as above.

Attributes:

	default_limit - A numeric value indicating the limit to use if one is not provided by the client in a query parameter. Defaults to the same value as the PAGE_SIZE settings key.
	limit_query_param - A string value indicating the name of the "limit" query parameter. Defaults to 'limit'.
	offset_query_param - A string value indicating the name of the "offset" query parameter. Defaults to 'offset'.
	max_limit - If set this is a numeric value indicating the maximum allowable limit that may be requested by the client. Defaults to None.
	template - The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to None to disable HTML pagination controls completely. Defaults to "rest_framework/pagination/numbers.html".



CursorPagination:
	The cursor-based pagination presents an opaque "cursor" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.
	Cursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.
	the default is to order by "-created". This assumes that there must be a 'created' timestamp field on the model instances, and will present a "timeline" style paginated view, with the most recently added items first.


Configuration of attribute:

	The CursorPagination class includes a number of attributes that may be overridden to modify the pagination style.
	To set these attributes you should override the CursorPagination class, and then enable your custom pagination class as above.

	page_size = A numeric value indicating the page size. If set, this overrides the PAGE_SIZE setting. Defaults to the same value as the PAGE_SIZE settings key.
	cursor_query_param = A string value indicating the name of the "cursor" query parameter. Defaults to 'cursor'.
	ordering = This should be a string, or list of strings, indicating the field against which the cursor based pagination will be applied. For example: ordering = 'slug'. Defaults to -created. This value may also be overridden by using OrderingFilter on the view.
	template = The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to None to disable HTML pagination controls completely. Defaults to "rest_framework/pagination/previous_and_next.html".



Setup:
	To enable the CursorPagination style globally, use the following configuration, modifying the PAGE_SIZE as desired:

	REST_FRAMEWORK = {
		'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.CursorPagination',
		'PAGE_SIZE': 100
	}

